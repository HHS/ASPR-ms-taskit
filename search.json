[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Taskit-Docs",
    "section": "",
    "text": "The Translation and Serialization Toolkit (Taskit)\nThe Translation and Serialization Toolkit (Taskit) is a Java library that facilitates converting between data files and Java objects. Users of Taskit should have a general familiarity with Java, object-oriented programming, serialization concepts, and serialization libraries.\nChanges to the documentation will be maintained in the table below:\n\nChange History\n\n\n\n\n\n\n\n\nID\nDate\nDescription\n\n\n\n\n1\n2025-04-15\nInitial Taskit documentation made available in Quarto",
    "crumbs": [
      "The Translation and Serialization Toolkit (Taskit)"
    ]
  },
  {
    "objectID": "ch01-Introduction.html",
    "href": "ch01-Introduction.html",
    "title": "1  Introduction",
    "section": "",
    "text": "1.1 Libraries\nTaskit is for Java applications that have large and/or complex data requirements. Developers implementing Taskit must adhere to ETL principles and maintain a clear separation between their input layer and application layer. Taskit can serialize/deserialize the input layer and translate it to/from the application layer.\nThe current iteration of Taskit is geared towards schema-based serialization libraries.\nTaskit is currently composed of two libraries: the Core Taskit library and the Protobuf Taskit library. The Core Taskit library provides the core interfaces, abstract classes, and classes that can be used to implement any serialization library. The Protobuf Taskit library builds upon the Core Taskit library to utilize the Protobuf serialization library.\nSupport for additional serialization libraries will be added in the future.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "ch02-CoreLibrary.html",
    "href": "ch02-CoreLibrary.html",
    "title": "2  Core Taskit Library",
    "section": "",
    "text": "2.1 High-Level Overview\nThe Core Taskit library defines the key components, common functionality, and process flow of Taskit. It provides interfaces, abstract classes, and classes that can be used to implement any serialization library.\nBefore jumping into the technical details of Taskit, it’s helpful to understand the core concepts at a high-level: what the key components are, how to set them up, and how data flows through them.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Core Taskit Library</span>"
    ]
  },
  {
    "objectID": "ch02-CoreLibrary.html#high-level-overview",
    "href": "ch02-CoreLibrary.html#high-level-overview",
    "title": "2  Core Taskit Library",
    "section": "",
    "text": "2.1.1 Key Components\n\nSerialization library: there must be a Taskit implementation of the selected serialization library\nData file: the exact structure of the data file is dependent on the implemented serialization library\nInputObject: a general term referring to a Java object native to the implemented serialization library\nAppObject: a general term referring to a Java object that is native to the developer’s application\nTranslationSpec: a Java object that defines how to translate between an InputObject and an AppObject\nTranslator: a Java object that bundles several TranslationSpecs that should/will often be used together\nTaskitEngine: a Java object, specific to the selected serialization library, responsible for reading and writing files and translating Java objects\nTaskitEngineManager: a Java object that can handle multiple TaskitEngines and direct requests to the appropriate TaskitEngine\n\nCertain components are always required, and some components are only required for translation. Some components are completely optional.\n\n2.1.1.1 Required Components\n\nSerialization library\nData file\nInputObject\nTaskitEngine\n\n\n\n2.1.1.2 Translation Required Components\n\nAppObject\nTranslationSpec\n\n\n\n2.1.1.3 Optional Components\n\nTranslator\nTaskitEngineManager\n\n\n\n\n2.1.2 Setting Up Taskit\n\n\n\n\n\n\n\n\n\nTo prepare to use Taskit within a Java application, first select a serialization library for which there is a Taskit implementation. If one does not already exist, it is relatively easy to create one. Next, if translation is required, create TranslationSpecs. Optionally, if you have lots of TranslationSpecs, you can create a Translator to bundle them together.\nTo use Taskit, instantiate your TranslationSpecs and any Translators, add them to the TaskitEngine, and then instantiate it. The TaskitEngine is now ready to receive requests. If you choose to use a TaskitEngineManager, add the TaskitEngine instances to it and then instantiate it. Direct requests to the TaskitEngineManager instead of directly calling the TaskitEngine.\n\n\n2.1.3 Process Flow\nData can take several paths through Taskit, such as:\n\nread from a data file and deserialize\nread from a data file, deserialize, and translate\nserialize and write to a data file\ntranslate, serialize, and write to a data file\n\n\n\n\n\n\n\n\n\n\nWhen reading, deserializing, and translating a data file, the request is sent to the TaskitEngine. If the TaskitEngineManager is used, it receives the request first and then sends it to the correct TaskitEngine. The TaskitEngine uses the serialization library to read and deserialize the data file into an InputObject. The TaskitEngine then uses the InputObject’s class reference to select the correct TranslationSpec and then calls it. The TranslationSpec takes in the InputObject and returns an AppObject. The application now has an AppObject that it can use.\n\n\n\n\n\n\n\n\n\nWhen translating, serializing, and writing an AppObject, the process is reversed. The AppObject is first translated into an InputObject which is then serialized and written to a data file.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Core Taskit Library</span>"
    ]
  },
  {
    "objectID": "ch02-CoreLibrary.html#translation",
    "href": "ch02-CoreLibrary.html#translation",
    "title": "2  Core Taskit Library",
    "section": "2.2 Translation",
    "text": "2.2 Translation\n\n2.2.1 TranslationSpecs\nA TranslationSpec contains the specific instructions for how to translate between two Java objects: an InputObject and an AppObject.\nA TranslationSpec can be added directly to a TaskitEngine or bundled into a Translator which in turn will add it to the TaskitEngine.\nThe Core Taskit library provides two TranslationSpec classes: ITranslationSpec and TranslationSpec. ITranslationSpec is an interface that declares four methods that all TranslationSpecs must implement: init, translate, isInitialized, and getTranslationSpecClassMapping. TranslationSpec is an abstract class that implements these methods as well as defining 4 abstract methods (listed below) that every concrete implementation must implement.\n\ntranslateInputObject\ntranslateAppObject\ngetAppObjectClass\ngetInputObjectClass\n\nAll TranslationSpecs receive a reference to a TaskitEngine during initialization, which can be used if it needs assistance translating a non-primitive object. Each TranslationSpec also provides a mapping of the types it can translate, which is used by the TaskitEngine for it’s internal mapping. During translation, a TranslationSpec validates the provided object, determines if it should be translated as an InputObject or an AppObject, and then delegates the translation work to the concrete implementation.\n\n\n2.2.2 Translators\nA Translator is an optional convenience class whose primary purpose is to bundle several TranslationSpecs that will be used together and provide a way to add them to a TaskitEngine. It also contains a dependency mechanism that gives developers the ability to group TranslationSpecs more logically while still maintaining functionality.\nA Translator is a non-extendable concrete class. Normally, this would be an interface, but how Translators are used behind the scenes is a bit complicated, so instead we provided a convenience class to handle that for you.\nEvery Translator must have a unique identifier in the form of a TranslatorId. This ID serves as a distinguisher between Translators and is an interface that must be implemented by the developer. This identifier is also used for the aforementioned dependency mechanism.\nEvery Translator must also have an initializer. The initializer is a consumer of a TranslatorContext. A TranslatorContext serves as a middleman between a Translator and a TaskitEngineBuilder. The builder of the TaskitEngine creates the TranslatorContext giving it a reference to itself, and the context provides a method by which to obtain that reference. Because each serialization library will have a specific TaskitEngine implementation, there may be cases where that implementation requires specific methods that don’t exist on the core TaskitEngine. So, a Translator and by proxy a TranslatorContext cannot just use a generic TaskitEngineBuilder, they must instead use a TaskitEngineBuilder specific to the given serialization library that is being used. As such, the initializer will have full access to all of the relevant methods on a TaskitEngineBuilder, allowing a Translator to do more than just add TranslationSpecs; however, this is very specific to a given serialization library and is not the norm, as previously stated, Translators are primarily used to group TranslationSpecs that will be used/are dependent on one another. If you are familiar with GCM, Translators are very akin to the Plugin concept of GCM.\nTranslator dependencies are optional but must follow a directed acyclic graph (DAG) pattern; there cannot be duplicate Translators, missing Translators, nor cyclic Translator dependencies. The use case of a Translator dependency is a case where one or more of a Translator’s TranslationSpecs has a dependency on another TranslationSpec that wouldn’t logically be grouped within the same Translator; for example, you might have a Translator that groups TranslationSpecs for property value classes, and another Translator that contains an implementer of a property value class, and thus would need to use a TranslationSpec from the property value Translator – the latter Translator would add a dependency on the property value Translator.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Core Taskit Library</span>"
    ]
  },
  {
    "objectID": "ch02-CoreLibrary.html#engine",
    "href": "ch02-CoreLibrary.html#engine",
    "title": "2  Core Taskit Library",
    "section": "2.3 Engine",
    "text": "2.3 Engine\n\n2.3.1 TaskitEngines\nA TaskitEngine is responsible for reading and writing data files and translating Java objects.\nThe Core Taskit library provides a TaskitEngine abstract class and a ITaskitEngineBuilder interface. It is the developer’s responsibility to ensure there is a TaskitEngine implementation for the selected serialization library. The implementation must implement the abstract methods declared in the TaskitEngine abstract class and have a builder that implements the ITaskitEngineBuilder interface. At a minimum, the implementation must implement the methods below:\n\nTaskitEngine\n\nwriteToFile\nreadFile\n\nITaskitEngineBuilder\n\naddTranslationSpec\naddTranslator\n\n\nEvery TaskitEngine must have a unique identifier in the form of a TaskitEngineId. This ID serves as a distinguisher between TaskitEngines and is an interface that must be implemented by the developer. Every TaskitEngine is constructed with a TaskitEngineData, which follows a builder pattern. At a minimum, the builder must be provided with one or more TranslationSpecs, which it stores in both a Map and a Set. The Map provides a mapping of types to the TranslationSpec capable of translating them. Generally, the Map will contain each TranslationSpec twice, so to avoid TranslationSpecs being initialized twice, they are also stored in the Set. If Translators are provided, the TaskitEngineData validates them to ensure they are initialized and follow a directed acyclic graph (DAG) pattern and then discards them. It is the responsibility of the concrete TaskitEngine implementation to ensure Translators are initialized.\nThe TaskitEngine class contains the core logic that all TaskitEngines will use. Normally, this would be an interface, but how TaskitEngines operate behind the scenes is a bit complicated, so instead we provided a convenience class to handle that for you.\nBefore a TaskitEngine can begin processing requests, it must be initialized. During initialization, the TaskitEngine calls init on each TranslationSpec and passes in a reference to itself. It is the responsibility of the TaskitEngine implementation to initialize itself.\nFor write requests, TaskitEngine validates the arguments, handles translation if requested, and then delegates the write to the concrete implementation. For read requests, it validates the arguments and then delegates the reading to the concrete implementation. If translation was requested, it then translates the read object.\nFor translations, TaskitEngine provides three options:\nOption 1: Translate the object using its class. This is the standard and most intuitive option. If an object is a Burger, translate it as if it was a Burger type. This option uses TaskitEngine’s translateObject method.\n\n\n\n\n\nFigure 2.1: Option 1: Translate the object using its class\n\n\n\n\n\n\n\n\nOption 2: Translate the object using a class reference that it extends or implements. If an object is a Burger, translate it as if it was a Food type. This translation is considered safe in the sense that the method parameter types ensure that the object is a child of the class reference. A conventional use case for this would be if the implemented serialization library did not understand inheritance. This option uses TaskitEngine’s translateObjectAsClassSafe method.\n\n\n\n\n\nFigure 2.2: Option 2: Translate the object using a class reference that it extends or implements\n\n\n\n\n\n\n\n\nOption 3: Translate the object using a class reference that it is not explicitly correlated with. If an object is a Burger, translate it as if it was a BurgerBox type. This translation is considered unsafe in the sense that the method parameter types provide no type safety and it is therefore up to the caller of the method to ensure that the object can be translated using the class reference. A conventional use case for this would be when you want to wrap an object into another object type, such as a BurgerBox that contains a Burger but is not itself a Burger. This option uses TaskitEngine’s translateObjectAsClassUnsafe method.\n\n\n\n\n\nFigure 2.3: Option 3: Translate the object using a class reference that it is not explicitly correlated with\n\n\n\n\n\n\n\n\n\n\n2.3.2 TaskitEngineManager\nA TaskitEngineManager can handle multiple TaskitEngines and direct requests to the appropriate TaskitEngine. It is optional and is purely a convenience class to aid with the use of multiple serialization libraries. Using a TaskitEngineManager with only one TaskitEngine serves no useful purpose.\nThe TaskitEngineManager class serves as a wrapper around the TaskitEngine’s read, write, and translate methods and uses the TaskitEngineId provided with the request to determine which engine to use.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Core Taskit Library</span>"
    ]
  },
  {
    "objectID": "ch03-ProtobufLibrary.html",
    "href": "ch03-ProtobufLibrary.html",
    "title": "3  Protobuf Taskit Library",
    "section": "",
    "text": "3.1 Translation\nThe Protobuf Taskit library is a version of Taskit made specifically to be used with Protobuf. It builds on the Core Taskit library and adds TaskitEngines and TranslationSpecs needed to fully support Protobuf.\nThe current iteration provides support for JSON and binary data formats.\nAll documentation from this point forward assumes you have read the Protobuf documentation and are, at a minimum, familiar with the topics listed below:",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Protobuf Taskit Library</span>"
    ]
  },
  {
    "objectID": "ch03-ProtobufLibrary.html#translation",
    "href": "ch03-ProtobufLibrary.html#translation",
    "title": "3  Protobuf Taskit Library",
    "section": "",
    "text": "3.1.1 TranslationSpecs\nThe Protobuf Taskit library provides the ProtobufTranslationSpec abstract class and several concrete implementations of it.\nProtobufTranslationSpec extends TranslationSpec and establishes that it must be initialized with a ProtobufTaskitEngine type.\nThe primary concrete implementation is the AnyTranslationSpec. Additional implementations for scalar types and enums are provided to support the Any type. Lastly, we also provided a convenient DateTranslationSpec to translate between a Java LocalDate and a Protobuf Date.\n\n3.1.1.1 AnyTranslationSpec\nThe AnyTranslationSpec translates between Java objects and a Protobuf Any message type. Protobuf does not support interfaces or inheritance, so to allow a message field to hold different concrete types, we use the Any type. For example, we can define a Food message with a single Any field. This lets us pack either a Burger or a HotDog message into that field. Later, we can unpack the Any to retrieve the original message type, thus enabling polymorphic behavior in an application.\nWhen translating an Any type, the AnyTranslationSpec grabs the typeUrl from the message and calls the ProtobufTaskitEngine to receive the corresponding class. It then uses the class to unpack the Any type into a Protobuf message. Lastly, it calls the TaskitEngine to translate the Protobuf message into a Java object that the application can use. The diagram below shows how the provided Any type is used to unpack a Protobuf message (InputObject) which is then translated into a Java object (AppObject).\n\n\n\n\n\nFigure 3.1: Translating an Any type\n\n\n\n\n\n\n\n\nTo have the AnyTranslationSpec translate a Java object into an Any type, you need to explicitly tell the TaskitEngine to translate the object as an Any.class. This ensures the TaskitEngine routes the request to the AnyTranslationSpec. If you do not specify the class, then the TaskitEngine will route the request to the TranslationSpec that translates it into its corresponding Protobuf message type, not an Any type. ProtobufTaskitEngine provides methods to get an object from an Any type and to get an Any type from an object, which will be discussed in Section 3.2.1.\nWhen translating a Java object, the AnyTranslationSpec has three options based on the type of object it was provided:\nOption 1: The provided object is a Java enum. It first calls the TaskitEngine to translate the object as an Enum.class and receives a WrapperEnumValue message. It then packs the WrapperEnumValue into an Any type and returns it. WrapperEnumValue is detailed below in Section 3.1.1.2, but is required for this specific description.\n\n\n\n\n\nFigure 3.2: Option 1: the provided object is a Java enum\n\n\n\n\n\n\n\n\nOption 2: The provided object is a Protobuf message. This may happen if the object was already translated before being sent to the AnyTranslationSpec. In this case, there is no need to translate it again so it simply packs the Protobuf message into an Any type and returns it.\n\n\n\n\n\nFigure 3.3: Option 2: the provided object is a Protobuf message\n\n\n\n\n\n\n\n\nOption 3: The provided object is not a Java enum or a Protobuf message. It first calls the TaskitEngine to translate the object into a Protobuf message. It then packs the Protobuf message into an Any type and returns it.\n\n\n\n\n\nFigure 3.4: Option 3: the provided object is not a Java enum or a Protobuf message\n\n\n\n\n\n\n\n\nAn Any message type can only wrap other Protobuf messages so it is necessary to have a way of translating Protobuf scalars and enums into a message. The Protobuf library provides message wrappers for scalars, such as BoolValue and Int32Value, and we provide convenient ProtobufTranslationSpecs (listed below) to covert between the most common ones and their Java equivalent. They are intuitive and do not require in-depth explanation.\n\nBooleanTranslationSpec\nIntegerTranslationSpec\nLongTranslationSpec\nStringTranslationSpec\nFloatTranslationSpec\nDoubleTranslationSpec\n\nThe process of wrapping an enum into a message is more complex and requires further explanation.\n\n\n3.1.1.2 WrapperEnumValue\nWrapperEnumValue is a Protobuf message used to wrap enums as messages so they can be packed into an Any type. It contains two strings: enumTypeUrl, which holds the enum’s full descriptor name, and value, which holds the enum’s value. The WrapperEnumValue is basically a clone of the Any message type, but exclusively used for Enums.\n\nmessage WrapperEnumValue {\n  string enumTypeUrl = 1;\n  string value = 2;\n}\n\nThe EnumTranslationSpec handles translation between Java enums and WrapperEnumValue. When translating a WrapperEnumValue, the EnumTranslationSpec grabs the enumTypeUrl from the message and calls the ProtobufTaskitEngine to receive the corresponding class. It then uses the class to create a Protobuf enum. Lastly, it calls the TaskitEngine to translate the Protobuf enum into a Java enum that the application can use. The diagram below shows how the provided WrapperEnumValue is used to create a Protobuf enum (InputEnum) which is then translated into a Java enum (AppEnum).\n\n\n\n\n\nFigure 3.5: Translating a WrapperEnumValue\n\n\n\n\n\n\n\n\nTo have the EnumTranslationSpec translate a Java enum into a WrapperEnumValue, you need to explicitly tell the TaskitEngine to translate the enum as an Enum.class. This ensures the TaskitEngine routes the request to the EnumTranslationSpec. If you do not specify the class, then the TaskitEngine will route the request to the TranslationSpec that translates it into its corresponding Protobuf enum, not a WrapperEnumValue.\nWhen translating a Java enum, the EnumTranslationSpec first calls the TaskitEngine to translate it into a Protobuf enum. It then uses the Protobuf enum’s value and full descriptor name to create and return a WrapperEnumValue. The diagram below shows how the provided Java enum (AppEnum) is translated into a Protobuf enum (InputEnum) which is then wrapped inside a WrapperEnumValue. Technically, yes, you could in theory wrap the AppEnum instead of wrapping the InputEnum, but to be consistent across the board, we wrap the InputEnum.\n\n\n\n\n\nFigure 3.6: Translating a Java enum\n\n\n\n\n\n\n\n\n\n\n\n3.1.2 Translators\nThe Protobuf Taskit library provides ProtobufTranslatorId and ProtobufTranslator to add the ProtobufTranslationSpecs mentioned in the previous section to a ProtobufTaskitEngine.\nDevelopers do not need to and should not add the ProtobufTranslator to the ProtobufTaskitEngines provided in the Protobuf Taskit library because the engines will automatically include it.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Protobuf Taskit Library</span>"
    ]
  },
  {
    "objectID": "ch03-ProtobufLibrary.html#engines",
    "href": "ch03-ProtobufLibrary.html#engines",
    "title": "3  Protobuf Taskit Library",
    "section": "3.2 Engines",
    "text": "3.2 Engines\nThe Protobuf Taskit library provides a ProtobufTaskitEngine abstract class and two concrete implementations of it: ProtobufBinaryTaskitEngine and ProtobufJsonTaskitEngine.\n\n3.2.1 ProtobufTaskitEngine\nProtobufTaskitEngine extends TaskitEngine from the Core Taskit library to implement logic that is common to all ProtobufTaskitEngine implementations.\nFor write requests, it casts the provided object to a Protobuf message type and then delegates the write to concrete implementations. For read requests, it creates a message builder type for the provided class, passes the builder and file to concrete implementations, and then casts the message to the provided class and returns it.\nProtobufTaskitEngine also provides support for translating between an Any type and a Java object. To help unpack Any values into the correct class, it has a variable called typeUrlToClassMap which maps Protobuf full descriptor names to their associated classes. It also provides convenience methods to make it more intuitive to translate between an Any and an object:\n\ngetObjectFromAny\ngetAnyFromObjectAsClassSafe\ngetAnyFromObject\n\nWhen getting an object from an Any type, it simply calls translateObject which will call the AnyTranslationSpec.\n\n\n\n\n\nFigure 3.7: Getting an Object from an Any type\n\n\n\n\n\n\n\n\nWhen getting an Any type from an object, it provides two options:\nOption 1: First safely translate the object using a class reference that it extends or implements (see TaskitEngine translation option 2: Chapter 2, Section 2.3.1). Then translate it as an Any type (see TaskitEngine translation option 3: Chapter 2, Section 2.3.1).\n\n\n\n\n\nFigure 3.8: Option 1: Safely getting an Any type from an Object\n\n\n\n\n\n\n\n\nOption 2: Directly translate the object as an Any type (see TaskitEngine translation option 3: Chapter 2, Section 2.3.1)\n\n\n\n\n\nFigure 3.9: Option 2: Unsafely getting an Any type from an Object\n\n\n\n\n\n\n\n\n\n\n3.2.2 ProtobufBinaryTaskitEngine\nProtobufBinaryTaskitEngine extends ProtobufTaskitEngine and implements the logic that is unique to reading and writing Protobuf binary data files.\nProtobufBinaryTaskitEngine follows a builder pattern, taking in Translators and ProtobufTranslationSpecs and does not require additional configuration to read and write files. When adding a Translator, it adds the Translator to a TaskitEngineData builder and then calls initialize on the Translator and passes in a TranslatorContext with a reference to itself. When adding a ProtobufTranslationSpec, it adds the ProtobufTranslationSpec to a TaskitEngineData builder and then grabs the InputObject’s full descriptor name to populate the typeUrlToClassMap.\nDuring the build process, the builder adds the ProtobufTranslator (Section 3.1.2), creates the TaskitEngineData, creates the ProtobufBinaryTaskitEngine, and initializes the engine before returning it. The engine is automatically built with a unique TaskitEngineId so the developer does not need to and should not manually set it.\nWhen writing, it uses Java’s BufferedOutputStream to write the message to the file. When reading, it uses Java’s BufferedInputStream to read the file into a message builder and then builds and returns the message.\n\n\n3.2.3 ProtobufJsonTaskitEngine\nProtobufJsonTaskitEngine extends ProtobufTaskitEngine and implements the logic that is unique to reading and writing JSON data files.\nProtobufJsonTaskitEngine follows a builder pattern, taking in Translators, ProtobufTranslationSpecs, and configuration settings for Protobuf’s JSON parser and printer. When adding a Translator, it adds the Translator to a TaskitEngineData builder and then calls initialize on the Translator and passes in a TranslatorContext with a reference to itself. When adding a ProtobufTranslationSpec, it adds the ProtobufTranslationSpec to a TaskitEngineData builder and then grabs the InputObject’s full descriptor name to populate the typeUrlToClassMap. If InputObject is a Protobuf message, it additionally grabs the message’s Descriptor and adds it to a Set called descriptorSet.\nThe descriptorSet is used to create a TypeRegistry, which the JSON parser and printer require to correctly resolve types stored in Any fields. This happens internally; no action is required from the developer, but it is described here for the sake of completeness.\nAdditionally, the parser and printer can be customized:\nThe parser’s default configuration ignores fields not defined in the associated Protobuf message schema, enabling forward and backward compatibility by allowing clients to accept messages with fields they do not recognize. If you tell the parser to not ignore these fields, it will throw an error whenever it encounters an unknown field, which is useful when strict adherence to .proto file schema is required.\nThe printer’s default configuration does not print scalar fields with default values. This setting can be turned on or off globally via the builder and can also be turned on for individual fields; this is an example of a case where the initializer of Translators would do more than just add TranslationSpecs, as mentioned in Chapter 2, Section 2.2.2.\nDuring the build process, the builder adds the ProtobufTranslator (Section 3.1.2), creates the parser and printer, creates the TaskitEngineData, creates the ProtobufJsonTaskitEngine, and initializes the engine before returning it. The engine is automatically built with a unique TaskitEngineId so the developer does not need to and should not manually set it.\nFor write requests, it uses Java’s BufferedWriter and the JSON printer to write the message to the file. For read requests, it uses Java’s BufferedReader and the JSON parser to read the file into a message builder and then builds and returns the message.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Protobuf Taskit Library</span>"
    ]
  }
]