<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.43">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>2&nbsp; Core Taskit Library â€“ Taskit-Docs</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./ch03-ProtobufLibrary.html" rel="next">
<link href="./ch01-Introduction.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-d4d76bf8491c20bad77d141916dc28e1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-8da5b4427184b79ecddefad3d342027e.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./ch02-CoreLibrary.html"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Core Taskit Library</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Taskit-Docs</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">The Translation and Serialization Toolkit (Taskit)</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ch01-Introduction.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Introduction</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ch02-CoreLibrary.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Core Taskit Library</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ch03-ProtobufLibrary.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Protobuf Taskit Library</span></span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active" data-toc-expanded="3">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#high-level-overview" id="toc-high-level-overview" class="nav-link active" data-scroll-target="#high-level-overview"><span class="header-section-number">2.1</span> High-Level Overview</a>
  <ul>
  <li><a href="#key-components" id="toc-key-components" class="nav-link" data-scroll-target="#key-components"><span class="header-section-number">2.1.1</span> Key Components</a>
  <ul class="collapse">
  <li><a href="#required-components" id="toc-required-components" class="nav-link" data-scroll-target="#required-components"><span class="header-section-number">2.1.1.1</span> Required Components</a></li>
  <li><a href="#translation-required-components" id="toc-translation-required-components" class="nav-link" data-scroll-target="#translation-required-components"><span class="header-section-number">2.1.1.2</span> Translation Required Components</a></li>
  <li><a href="#optional-components" id="toc-optional-components" class="nav-link" data-scroll-target="#optional-components"><span class="header-section-number">2.1.1.3</span> Optional Components</a></li>
  </ul></li>
  <li><a href="#setting-up-taskit" id="toc-setting-up-taskit" class="nav-link" data-scroll-target="#setting-up-taskit"><span class="header-section-number">2.1.2</span> Setting Up Taskit</a></li>
  <li><a href="#process-flow" id="toc-process-flow" class="nav-link" data-scroll-target="#process-flow"><span class="header-section-number">2.1.3</span> Process Flow</a></li>
  </ul></li>
  <li><a href="#translation" id="toc-translation" class="nav-link" data-scroll-target="#translation"><span class="header-section-number">2.2</span> Translation</a>
  <ul>
  <li><a href="#translationspecs" id="toc-translationspecs" class="nav-link" data-scroll-target="#translationspecs"><span class="header-section-number">2.2.1</span> TranslationSpecs</a></li>
  <li><a href="#sec-translators" id="toc-sec-translators" class="nav-link" data-scroll-target="#sec-translators"><span class="header-section-number">2.2.2</span> Translators</a></li>
  </ul></li>
  <li><a href="#engine" id="toc-engine" class="nav-link" data-scroll-target="#engine"><span class="header-section-number">2.3</span> Engine</a>
  <ul>
  <li><a href="#sec-taskitEngines" id="toc-sec-taskitEngines" class="nav-link" data-scroll-target="#sec-taskitEngines"><span class="header-section-number">2.3.1</span> TaskitEngines</a></li>
  <li><a href="#taskitenginemanager" id="toc-taskitenginemanager" class="nav-link" data-scroll-target="#taskitenginemanager"><span class="header-section-number">2.3.2</span> TaskitEngineManager</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Core Taskit Library</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>The Core Taskit library defines the key components, common functionality, and process flow of Taskit. It provides interfaces, abstract classes, and classes that can be used to implement any serialization library.</p>
<section id="high-level-overview" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="high-level-overview"><span class="header-section-number">2.1</span> High-Level Overview</h2>
<p>Before jumping into the technical details of Taskit, itâ€™s helpful to understand the core concepts at a high-level: what the key components are, how to set them up, and how data flows through them.</p>
<section id="key-components" class="level3" data-number="2.1.1">
<h3 data-number="2.1.1" class="anchored" data-anchor-id="key-components"><span class="header-section-number">2.1.1</span> Key Components</h3>
<ul>
<li><p><strong>Serialization library</strong>: there must be a Taskit implementation of the selected serialization library</p></li>
<li><p><strong>Data file</strong>: the exact structure of the data file is dependent on the implemented serialization library</p></li>
<li><p><strong>InputObject</strong>: a general term referring to a Java object native to the implemented serialization library</p></li>
<li><p><strong>AppObject</strong>: a general term referring to a Java object that is native to the developerâ€™s application</p></li>
<li><p><strong>TranslationSpec</strong>: a Java object that defines how to translate between an InputObject and an AppObject</p></li>
<li><p><strong>Translator</strong>: a Java object that bundles several TranslationSpecs that should/will often be used together</p></li>
<li><p><strong>TaskitEngine</strong>: a Java object, specific to the selected serialization library, responsible for reading and writing files and translating Java objects</p></li>
<li><p><strong>TaskitEngineManager</strong>: a Java object that can handle multiple TaskitEngines and direct requests to the appropriate TaskitEngine</p></li>
</ul>
<p>Certain components are always required, and some components are only required for translation. Some components are completely optional.</p>
<section id="required-components" class="level4" data-number="2.1.1.1">
<h4 data-number="2.1.1.1" class="anchored" data-anchor-id="required-components"><span class="header-section-number">2.1.1.1</span> Required Components</h4>
<ul>
<li><p>Serialization library</p></li>
<li><p>Data file</p></li>
<li><p>InputObject</p></li>
<li><p>TaskitEngine</p></li>
</ul>
</section>
<section id="translation-required-components" class="level4" data-number="2.1.1.2">
<h4 data-number="2.1.1.2" class="anchored" data-anchor-id="translation-required-components"><span class="header-section-number">2.1.1.2</span> Translation Required Components</h4>
<ul>
<li><p>AppObject</p></li>
<li><p>TranslationSpec</p></li>
</ul>
</section>
<section id="optional-components" class="level4" data-number="2.1.1.3">
<h4 data-number="2.1.1.3" class="anchored" data-anchor-id="optional-components"><span class="header-section-number">2.1.1.3</span> Optional Components</h4>
<ul>
<li><p>Translator</p></li>
<li><p>TaskitEngineManager</p></li>
</ul>
</section>
</section>
<section id="setting-up-taskit" class="level3" data-number="2.1.2">
<h3 data-number="2.1.2" class="anchored" data-anchor-id="setting-up-taskit"><span class="header-section-number">2.1.2</span> Setting Up Taskit</h3>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="inputimages/SettingUpTaskit.svg" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>To prepare to use Taskit within a Java application, first select a serialization library for which there is a Taskit implementation. If one does not already exist, it is relatively easy to create one. Next, if translation is required, create TranslationSpecs. Optionally, if you have lots of TranslationSpecs, you can create a Translator to bundle them together.</p>
<p>To use Taskit, instantiate your TranslationSpecs and any Translators, add them to the TaskitEngine, and then instantiate it. The TaskitEngine is now ready to receive requests. If you choose to use a TaskitEngineManager, add the TaskitEngine instances to it and then instantiate it. Direct requests to the TaskitEngineManager instead of directly calling the TaskitEngine.</p>
</section>
<section id="process-flow" class="level3" data-number="2.1.3">
<h3 data-number="2.1.3" class="anchored" data-anchor-id="process-flow"><span class="header-section-number">2.1.3</span> Process Flow</h3>
<p>Data can take several paths through Taskit, such as:</p>
<ul>
<li><p>read from a data file and deserialize</p></li>
<li><p>read from a data file, deserialize, and translate</p></li>
<li><p>serialize and write to a data file</p></li>
<li><p>translate, serialize, and write to a data file</p></li>
</ul>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="inputimages/ReadingProcessFlow.svg" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>When reading, deserializing, and translating a data file, the request is sent to the TaskitEngine. If the TaskitEngineManager is used, it receives the request first and then sends it to the correct TaskitEngine. The TaskitEngine uses the serialization library to read and deserialize the data file into an InputObject. The TaskitEngine then uses the InputObjectâ€™s class reference to select the correct TranslationSpec and then calls it. The TranslationSpec takes in the InputObject and returns an AppObject. The application now has an AppObject that it can use.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="inputimages/WritingProcessFlow.svg" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>When translating, serializing, and writing an AppObject, the process is reversed. The AppObject is first translated into an InputObject which is then serialized and written to a data file.</p>
</section>
</section>
<section id="translation" class="level2" data-number="2.2">
<h2 data-number="2.2" class="anchored" data-anchor-id="translation"><span class="header-section-number">2.2</span> Translation</h2>
<section id="translationspecs" class="level3" data-number="2.2.1">
<h3 data-number="2.2.1" class="anchored" data-anchor-id="translationspecs"><span class="header-section-number">2.2.1</span> TranslationSpecs</h3>
<p>A TranslationSpec contains the specific instructions for how to translate between two Java objects: an InputObject and an AppObject.</p>
<p>A TranslationSpec can be added directly to a TaskitEngine or bundled into a Translator which in turn will add it to the TaskitEngine.</p>
<p>The Core Taskit library provides two TranslationSpec classes: ITranslationSpec and TranslationSpec. ITranslationSpec is an interface that declares four methods that all TranslationSpecs must implement: init, translate, isInitialized, and getTranslationSpecClassMapping. TranslationSpec is an abstract class that implements these methods as well as defining 4 abstract methods (listed below) that every concrete implementation must implement.</p>
<ul>
<li>translateInputObject</li>
<li>translateAppObject</li>
<li>getAppObjectClass</li>
<li>getInputObjectClass</li>
</ul>
<p>All TranslationSpecs receive a reference to a TaskitEngine during initialization, which can be used if it needs assistance translating a non-primitive object. Each TranslationSpec also provides a mapping of the types it can translate, which is used by the TaskitEngine for itâ€™s internal mapping. During translation, a TranslationSpec validates the provided object, determines if it should be translated as an InputObject or an AppObject, and then delegates the translation work to the concrete implementation.</p>
</section>
<section id="sec-translators" class="level3" data-number="2.2.2">
<h3 data-number="2.2.2" class="anchored" data-anchor-id="sec-translators"><span class="header-section-number">2.2.2</span> Translators</h3>
<p>A Translator is an optional convenience class whose primary purpose is to bundle several TranslationSpecs that will be used together and provide a way to add them to a TaskitEngine. It also contains a dependency mechanism that gives developers the ability to group TranslationSpecs more logically while still maintaining functionality.</p>
<p>A Translator is a non-extendable concrete class. Normally, this would be an interface, but how Translators are used behind the scenes is a bit complicated, so instead we provided a convenience class to handle that for you.</p>
<p>Every Translator must have a unique identifier in the form of a TranslatorId. This ID serves as a distinguisher between Translators and is an interface that must be implemented by the developer. This identifier is also used for the aforementioned dependency mechanism.</p>
<p>Every Translator must also have an initializer. The initializer is a consumer of a TranslatorContext. A TranslatorContext serves as a middleman between a Translator and a TaskitEngineBuilder. The builder of the TaskitEngine creates the TranslatorContext giving it a reference to itself, and the context provides a method by which to obtain that reference. Because each serialization library will have a specific TaskitEngine implementation, there may be cases where that implementation requires specific methods that donâ€™t exist on the core TaskitEngine. So, a Translator and by proxy a TranslatorContext cannot just use a generic TaskitEngineBuilder, they must instead use a TaskitEngineBuilder specific to the given serialization library that is being used. As such, the initializer will have full access to all of the relevant methods on a TaskitEngineBuilder, allowing a Translator to do more than just add TranslationSpecs; however, this is very specific to a given serialization library and is not the norm, as previously stated, Translators are primarily used to group TranslationSpecs that will be used/are dependent on one another. If you are familiar with GCM, Translators are very akin to the Plugin concept of GCM.</p>
<p>Translator dependencies are optional but must follow a directed acyclic graph (DAG) pattern; there cannot be duplicate Translators, missing Translators, nor cyclic Translator dependencies. The use case of a Translator dependency is a case where one or more of a Translatorâ€™s TranslationSpecs has a dependency on another TranslationSpec that wouldnâ€™t logically be grouped within the same Translator; for example, you might have a Translator that groups TranslationSpecs for property value classes, and another Translator that contains an implementer of a property value class, and thus would need to use a TranslationSpec from the property value Translator â€“ the latter Translator would add a dependency on the property value Translator.</p>
</section>
</section>
<section id="engine" class="level2" data-number="2.3">
<h2 data-number="2.3" class="anchored" data-anchor-id="engine"><span class="header-section-number">2.3</span> Engine</h2>
<section id="sec-taskitEngines" class="level3" data-number="2.3.1">
<h3 data-number="2.3.1" class="anchored" data-anchor-id="sec-taskitEngines"><span class="header-section-number">2.3.1</span> TaskitEngines</h3>
<p>A TaskitEngine is responsible for reading and writing data files and translating Java objects.</p>
<p>The Core Taskit library provides a TaskitEngine abstract class and a ITaskitEngineBuilder interface. It is the developerâ€™s responsibility to ensure there is a TaskitEngine implementation for the selected serialization library. The implementation must implement the abstract methods declared in the TaskitEngine abstract class and have a builder that implements the ITaskitEngineBuilder interface. At a minimum, the implementation must implement the methods below:</p>
<ul>
<li><p>TaskitEngine</p>
<ul>
<li><p>writeToFile</p></li>
<li><p>readFile</p></li>
</ul></li>
<li><p>ITaskitEngineBuilder</p>
<ul>
<li><p>addTranslationSpec</p></li>
<li><p>addTranslator</p></li>
</ul></li>
</ul>
<p>Every TaskitEngine must have a unique identifier in the form of a TaskitEngineId. This ID serves as a distinguisher between TaskitEngines and is an interface that must be implemented by the developer. Every TaskitEngine is constructed with a TaskitEngineData, which follows a builder pattern. At a minimum, the builder must be provided with one or more TranslationSpecs, which it stores in both a Map and a Set. The Map provides a mapping of types to the TranslationSpec capable of translating them. Generally, the Map will contain each TranslationSpec twice, so to avoid TranslationSpecs being initialized twice, they are also stored in the Set. If Translators are provided, the TaskitEngineData validates them to ensure they are initialized and follow a directed acyclic graph (DAG) pattern and then discards them. It is the responsibility of the concrete TaskitEngine implementation to ensure Translators are initialized.</p>
<p>The TaskitEngine class contains the core logic that all TaskitEngines will use. Normally, this would be an interface, but how TaskitEngines operate behind the scenes is a bit complicated, so instead we provided a convenience class to handle that for you.</p>
<p>Before a TaskitEngine can begin processing requests, it must be initialized. During initialization, the TaskitEngine calls init on each TranslationSpec and passes in a reference to itself. It is the responsibility of the TaskitEngine implementation to initialize itself.</p>
<p>For write requests, TaskitEngine validates the arguments, handles translation if requested, and then delegates the write to the concrete implementation. For read requests, it validates the arguments and then delegates the reading to the concrete implementation. If translation was requested, it then translates the read object.</p>
<p>For translations, TaskitEngine provides three options:</p>
<p>Option 1: Translate the object using its class. This is the standard and most intuitive option. If an object is a Burger, translate it as if it was a Burger type. This option uses TaskitEngineâ€™s translateObject method.</p>
<div class="cell">
<div class="cell-output-display">
<div id="fig-TranslateBurgerAsBurger" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-fig" id="fig-TranslateBurgerAsBurger-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2.1: Option 1: Translate the object using its class
</figcaption>
<div aria-describedby="fig-TranslateBurgerAsBurger-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="inputimages/TranslateBurgerAsBurger.svg" class="img-fluid figure-img">
</div>
</figure>
</div>
</div>
</div>
<p>Option 2: Translate the object using a class reference that it extends or implements. If an object is a Burger, translate it as if it was a Food type. This translation is considered safe in the sense that the method parameter types ensure that the object is a child of the class reference. A conventional use case for this would be if the implemented serialization library did not understand inheritance. This option uses TaskitEngineâ€™s translateObjectAsClassSafe method.</p>
<div class="cell">
<div class="cell-output-display">
<div id="fig-TranslateBurgerAsFood" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-fig" id="fig-TranslateBurgerAsFood-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2.2: Option 2: Translate the object using a class reference that it extends or implements
</figcaption>
<div aria-describedby="fig-TranslateBurgerAsFood-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="inputimages/TranslateBurgerAsFood.svg" class="img-fluid figure-img">
</div>
</figure>
</div>
</div>
</div>
<p>Option 3: Translate the object using a class reference that it is not explicitly correlated with. If an object is a Burger, translate it as if it was a BurgerBox type. This translation is considered unsafe in the sense that the method parameter types provide no type safety and it is therefore up to the caller of the method to ensure that the object can be translated using the class reference. A conventional use case for this would be when you want to wrap an object into another object type, such as a BurgerBox that contains a Burger but is not itself a Burger. This option uses TaskitEngineâ€™s translateObjectAsClassUnsafe method.</p>
<div class="cell">
<div class="cell-output-display">
<div id="fig-TranslateBurgerAsBurgerBox" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-fig" id="fig-TranslateBurgerAsBurgerBox-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2.3: Option 3: Translate the object using a class reference that it is not explicitly correlated with
</figcaption>
<div aria-describedby="fig-TranslateBurgerAsBurgerBox-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="inputimages/TranslateBurgerAsBurgerBox.svg" class="img-fluid figure-img">
</div>
</figure>
</div>
</div>
</div>
</section>
<section id="taskitenginemanager" class="level3" data-number="2.3.2">
<h3 data-number="2.3.2" class="anchored" data-anchor-id="taskitenginemanager"><span class="header-section-number">2.3.2</span> TaskitEngineManager</h3>
<p>A TaskitEngineManager can handle multiple TaskitEngines and direct requests to the appropriate TaskitEngine. It is optional and is purely a convenience class to aid with the use of multiple serialization libraries. Using a TaskitEngineManager with only one TaskitEngine serves no useful purpose.</p>
<p>The TaskitEngineManager class serves as a wrapper around the TaskitEngineâ€™s read, write, and translate methods and uses the TaskitEngineId provided with the request to determine which engine to use.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "î§‹";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./ch01-Introduction.html" class="pagination-link" aria-label="Introduction">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Introduction</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./ch03-ProtobufLibrary.html" class="pagination-link" aria-label="Protobuf Taskit Library">
        <span class="nav-page-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Protobuf Taskit Library</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>